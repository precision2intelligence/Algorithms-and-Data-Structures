#**1 不开辟额外空间的解法
#时间复杂度：O(n)
#空间复杂度：O(1)
def move_zero(arr):
    if not arr or len(arr)<=1:
        return arr
    k=0
    for i in range(len(arr)):
        if arr[i]!=0:
            arr[k],arr[i]=arr[i],arr[k]
            k+=1
    return arr
    
    
——————————————————————————————————————————————————题目中要求无返回值，原地排列————————————————————————————————————————————    
    
#**2 增加了空间复杂度   
#时间复杂度：O(n)
#空间复杂度：O(n)
def move_zero(arr):
    if not arr or len(arr)<=1:
        return arr
    k=0       #k只是计数
    res=[]
    for i in range(len(arr)):
        if arr[i]!=0:
            res.append(arr[i])
            k+=1
    for j in range(len(arr)-k):#注意这里是剩下的0的个数
        res.append(0)
    return res

_________________________________________不用开辟新空间的原地排列法，比第二种简单_________________________________________
#**3 增加了空间复杂度   
#时间复杂度：O(n)
#空间复杂度：O(1)
def move_zero(arr):
    if not arr or len(arr)<=1:
        return arr
    k=0       #k只是计数
    for i in range(len(arr)):
            if arr[i]!=0:
                arr[k]=arr[i]
                k+=1
        for i in range(k,len(nums)):
            arr[i]=0
